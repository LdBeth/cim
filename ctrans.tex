\input cwebmac
% -*- mode:cweb -*-
\def\title{CIM - The Cangjie Input Method for 9front}


\N{1}{1}Introduction. This program translates input from {\tt /dev/kbd} to
Chinese runes. The idea is based on {\tt ktrans} but this is a rewrite
to have much cleaner code and the efficiency for handling a much
bigger dictionary.

The usage is the almost the same as {\tt ktrans}: just invoke {\tt
cim} before {\tt rio}.

{\tt \^{}T} gives you English mode, {\tt \^{}N} enters Cangjie mode.
{\tt \^{}L} rotates selection.

I know you might want Pinyin but Cangjie is a little bit easier to
implement and way easier to use when there is no prompt.


\fi

\N{1}{2}Setup keyboard I/O. See {\tt kbdfs(8)}. Reading {\tt /dev/kbd} gives
keycodes and the {\tt c} messages are what we want to process. Besides
handling the event produced by the operating system, we need also to
ensure other programs that read {\tt /dev/kbd} can acquire the
translated result by faking a new keyboard device to shadow the
original one.

\Y\B\4\X2:Setup keyboard\X${}\E{}$\6
\&{if} ${}((\\{kbd}\K\\{open}(\.{"/dev/kbd"},\39\.{OREAD}))<\T{0})\3{-1}{}$\1\5
\\{sysfatal}(\.{"open\ kbd:\ \%r"});\2\6
\X4:Shadowing {\tt/dev/kbd}\X\par
\U29.\fi

\M{3}\B\X3:Variables\X${}\E{}$\6
\&{int} \\{kbd}${},{}$ \\{newkbd};\par
\A6.
\U29.\fi

\M{4}The call \PB{$\\{bind}(\.{"\#|"},\\{dir},\.{MREPL})$} would create a pair
of pipes named
{\tt data} and {\tt data1} in \PB{\\{dir}}.

\Y\B\4\X4:Shadowing {\tt/dev/kbd}\X${}\E{}$\6
\&{if} ${}(\\{bind}(\.{"\#|"},\39\.{"/n/temp"},\39\.{MREPL})<\T{0})\3{-1}{}$\1\5
\\{sysfatal}(\.{"bind\ /n/temp:\ \%r"});\2\6
\&{if} ${}((\\{newkbd}\K\\{open}(\.{"/n/temp/data1"},\39\.{OWRITE}))<\T{0})%
\3{-1}{}$\1\5
\\{sysfatal}(\.{"open\ kbd\ pipe:\ \%r"});\2\6
\&{if} ${}(\\{bind}(\.{"/n/temp/data"},\39\.{"/dev/kbd"},\39\.{MREPL})<\T{0})%
\3{-1}{}$\1\5
\\{sysfatal}(\.{"bind\ kbd\ pipe:\ \%r"});\2\6
${}\\{unmount}(\\{nil},\39\.{"/n/temp"}){}$;\par
\U2.\fi

\M{5}This loop would be used to intercept input and output translated
result. When the start of the message is \PB{\.{'c'}} the following stting
contains one character.  The function \PB{\\{nextstate}(\,)} would output runes
to \PB{\\{newkbd}} when possible.

\Y\B\4\X5:Key translation loop\X${}\E{}$\6
\&{while} ${}((\|n\K\\{read}(\\{kbd},\39\\{buf},\39{}$\&{sizeof} (%
\\{buf})))${}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{buf}[\|n-\T{1}]\K\T{0};{}$\6
\&{if} ${}(\|n<\T{2}\V\\{buf}[\T{0}]\I\.{'c'})\3{-1}{}$\1\5
${}\\{write}(\\{newkbd},\39\\{buf},\39\|n);{}$\2\6
\&{else}\1\5
${}\\{nextstate}(\\{buf},\39\|n,\39\\{newkbd});{}$\2\6
\4${}\}{}$\2\par
\U29.\fi

\M{6}\B\X3:Variables\X${}\mathrel+\E{}$\6
\&{int} \|n;\6
\&{char} \\{buf}[\T{128}];\par
\fi

\N{1}{7}Dictionary. The dictionary is defined as several C arrays in a
separated file named {\tt dict.c}. It has to be generated by a
external program and that detail would not be discussed here.  The
requirement for dictionary is that all entries need to be sorted
with lexicographical order.

\Y\B\F\\{Rune}\5
\\{char}\C{ Rune is the type for Unicode characters }\par
\Y\B\4\X7:Declarations\X${}\E{}$\6
\&{typedef} \&{struct} \\{Map} \&{Map};\6
\&{struct} \&{Map} ${}\{{}$\1\6
\&{char} ${}{*}\\{key};{}$\6
\&{Rune} ${}{*}\\{val};{}$\2\6
${}\};{}$\6
\&{extern} \&{const} \&{Map} \\{dict}[\,];\par
\A8.
\U29.\fi

\M{8}There are two precomputed indices to speed up lookup.
\Y\B\4\X7:Declarations\X${}\mathrel+\E{}$\6
\&{extern} \&{const} \&{int} \\{lvl1}[\,];\6
\&{extern} \&{const} \&{int} \\{lvl2}[\,];\par
\fi

\M{9}\PB{\\{lvl1}} contains indices from \PB{\.{"a"}} to \PB{\.{"z"}}.
\Y\B\4\X9:Lookup in \PB{\\{lvl1}}\X${}\E{}$\6
\&{return} ${}{\AND}\\{dict}[\\{lvl1}[\\{key}[\T{0}]-\.{'a'}]]{}$;\par
\U11.\fi

\M{10}\PB{\\{lvl2}} contains indices from \PB{\.{"aa"}}, \PB{\.{"ab"}} to \PB{%
\.{"zz"}}. Since it is
likely the indices are sparse, a negative value indicates not found.

\Y\B\4\X10:Lookup in \PB{\\{lvl2}}\X${}\E{}$\6
${}\{{}$\1\6
\&{int} \\{index}${}\K\\{lvl2}[(\\{key}[\T{0}]-\.{'a'})*\T{26}+(\\{key}[\T{1}]-%
\.{'a'})];{}$\7
\&{return} ${}(\\{index}<\T{0})\?\\{nil}:{\AND}\\{dict}[\\{index}];{}$\6
\4${}\}{}$\2\par
\U11.\fi

\M{11}Find in the dictionary. Since the indices are very sparse after
level 2, only linear search would be needed. The optional argument
\PB{\\{table}} can be used to resume a search.

\Y\B\4\X11:Subroutines\X${}\E{}$\6
\1\1\&{const} \&{Map} ${}{*}{}$\\{match}(\&{const} \&{char} ${}{*}\\{key},%
\39{}$\&{int} \\{len}${},\39{}$\&{const} \&{Map} ${}{*}\\{table})\2\2{}$\6
${}\{{}$\1\6
\&{switch} (\\{len})\5
${}\{{}$\1\6
\4\&{case} \T{1}:\5
\X9:Lookup in \PB{\\{lvl1}}\X\6
\4\&{case} \T{2}:\5
\X10:Lookup in \PB{\\{lvl2}}\X\6
\4\&{default}:\6
\&{if} ${}(\\{table}\I\\{nil}){}$\1\5
\X13:Linear search\X\2\6
\&{else}\1\5
\X12:Speedup with \PB{\\{lvl2}}\X\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\A15.
\U29.\fi

\M{12}\B\X12:Speedup with \PB{\\{lvl2}}\X${}\E{}$\6
\&{return} \\{match}${}(\\{key},\39\\{len},\39\\{match}(\\{key},\39\T{2},\39%
\\{nil})){}$;\par
\U11.\fi

\M{13}Using \PB{\\{strncmp}} to search key prefixes in the dictionary, since
the
keys are ordered, if the compare result is negative, return \PB{\\{nil}}. The
first two characters of the dictionary key are omitted for space
efficiency.  If the key's length is less than 3 it is only stored as
\PB{\\{nil}}.

\Y\B\4\X13:Linear search\X${}\E{}$\6
${}\{{}$\1\6
\&{int} \\{cmp};\6
\&{char} ${}{*}\\{newkey}\K{\AND}\\{key}[\T{2}];{}$\7
\&{for} \X14:First none \PB{\\{nil}} key until next \PB{\\{nil}}\X\5
${}\{{}$\1\6
${}\\{cmp}\K\\{strncmp}(\\{newkey},\39\\{table}[\|i].\\{key},\39(\\{len}-%
\T{2}));{}$\6
\&{if} ${}(\\{cmp}\E\T{0}){}$\1\5
\&{return} ${}{\AND}\\{table}[\|i];{}$\2\6
\&{else} \&{if} ${}(\\{cmp}<\T{0}){}$\1\5
\&{return} \\{nil};\2\6
\4${}\}{}$\2\6
\&{return} \\{nil};\6
\4${}\}{}$\2\par
\U11.\fi

\M{14}When a two character key doesn't exist, the index for next key with
same prefix is stored.
\Y\B\4\X14:First none \PB{\\{nil}} key until next \PB{\\{nil}}\X${}\E{}$\6
(\&{int} \|i${}\K(\\{table}[\T{0}].\\{key})\?\T{0}:\T{1};{}$ ${}\\{table}[\|i].%
\\{key};{}$ ${}\|i\PP{}$)\par
\U13.\fi

\N{1}{15}State machine. Right now this is a bit of messy.

\Y\B\4\X11:Subroutines\X${}\mathrel+\E{}$\6
\1\1\&{void} \\{nextstate}(\&{char} ${}{*}\\{oldbuf},\39{}$\&{int} \|n${},%
\39{}$\&{int} \\{outfd})\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{len}>\T{5}){}$\5
${}\{{}$\1\6
${}\\{len}\K\T{0};{}$\6
${}\\{laststate}\K\\{nil};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{natural}\W\\{islower}(\\{oldbuf}[\T{1}])){}$\5
${}\{{}$\1\6
\X24:Copy input character to input buffer\X\6
\X17:Search and output\X\6
\&{return};\6
\4${}\}{}$\2\6
\&{else}\1\5
\X16:Handle mode change and selection\X\2\6
\X26:Directly write to output\X\6
\&{return};\6
\4${}\}{}$\2\par
\fi

\M{16}\B\X16:Handle mode change and selection\X${}\E{}$\6
\&{if} ${}(\\{oldbuf}[\T{1}]\E\T{20}){}$\5
${}\{{}$\SHC{ {\tt \^{}T} }\1\6
${}\\{natural}\K\T{1};{}$\6
\X23:Reset state\X\6
\&{return};\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{oldbuf}[\T{1}]\E\T{14}){}$\5
${}\{{}$\SHC{ {\tt \^{}N} }\1\6
${}\\{natural}\K\T{0};{}$\6
\X23:Reset state\X\6
\&{return};\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\R\\{natural}\W\\{oldbuf}[\T{1}]\E\.{'\ '}){}$\5
${}\{{}$\1\6
\X23:Reset state\X\6
\&{return};\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{oldbuf}[\T{1}]\E\T{12}){}$\5
${}\{{}$\SHC{ {\tt \^{}L} }\1\6
\X18:Rotate selection\X\6
\&{return};\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{oldbuf}[\T{1}]\E\.{'\\b'}){}$\5
${}\{{}$\1\6
\X23:Reset state\X\6
\4${}\}{}$\2\par
\U15.\fi

\M{17}The only \PB{\&{goto}} statement in this program. It enables auto start
of next input if the last character is already complete.
\Y\B\4\X17:Search and output\X${}\E{}$\6
\4\\{search}:\5
\&{Map} ${}{*}\\{result}\K\\{match}(\\{input},\39\\{len},\39\\{laststate});{}$\7
\&{if} ${}(\\{result}\I\\{nil}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{laststate}\I\\{nil}){}$\1\5
\X21:Backspace\X\2\6
${}\\{candidate}\K\\{result}\MG\\{val};{}$\6
\X20:Write current candidate\X\6
${}\\{laststate}\K\\{result};{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{laststate}\I\\{nil}){}$\5
${}\{{}$\1\6
\X25:Flush input buffer until the but last character\X\6
\&{goto} \\{search};\6
\4${}\}{}$\2\par
\U15.\fi

\M{18}\B\X18:Rotate selection\X${}\E{}$\6
\&{if} ${}(\\{laststate}\I\\{nil}){}$\5
${}\{{}$\1\6
\X21:Backspace\X\6
${}\\{candidate}\PP;{}$\6
\&{if} ${}(\R{*}\\{candidate}){}$\1\5
${}\\{candidate}\K\\{laststate}\MG\\{val};{}$\2\6
\X20:Write current candidate\X\6
\4${}\}{}$\2\par
\U16.\fi

\M{19}\B\X19:Global states\X${}\E{}$\6
\&{Rune} ${}{*}\\{candidate}{}$;\par
\As22\ET27.
\U29.\fi

\M{20}\B\X20:Write current candidate\X${}\E{}$\6
\&{char} \\{buf}[\T{128}];\6
\&{int} \|n${}\K\\{snprint}(\\{buf},\39{}$\&{sizeof} (\\{buf})${},\39\.{"c%
\%C"},\39{*}\\{candidate})+\T{1};{}$\7
${}\\{write}(\\{outfd},\39\\{buf},\39\|n){}$;\par
\Us17\ET18.\fi

\M{21}\B\X21:Backspace\X${}\E{}$\6
$\\{write}(\\{outfd},\39\.{"c\\b\\0"},\39\T{3}){}$;\par
\Us17\ET18.\fi

\M{22}These states keeps a record of current input.
\Y\B\4\X19:Global states\X${}\mathrel+\E{}$\6
\&{char} \\{input}[\T{20}];\6
\&{int} \\{len}${}\K\T{0};{}$\6
\&{Map} ${}{*}\\{laststate}\K\\{nil}{}$;\par
\fi

\M{23}\B\X23:Reset state\X${}\E{}$\6
$\\{len}\K\T{0};{}$\6
${}\\{laststate}\K\\{nil}{}$;\par
\U16.\fi

\M{24}\B\X24:Copy input character to input buffer\X${}\E{}$\6
$\\{input}[\\{len}]\K\\{oldbuf}[\T{1}];{}$\6
${}\\{len}\MRL{+{\K}}\T{1};{}$\6
${}\\{input}[\\{len}]\K\.{'\\0'}{}$;\par
\U15.\fi

\M{25}\B\X25:Flush input buffer until the but last character\X${}\E{}$\6
$\\{input}[\T{0}]\K\\{input}[\\{len}-\T{1}];{}$\6
${}\\{input}[\T{1}]\K\.{'\\0'};{}$\6
${}\\{len}\K\T{1}{}$;\par
\U17.\fi

\M{26}\B\X26:Directly write to output\X${}\E{}$\6
$\\{write}(\\{outfd},\39\\{oldbuf},\39\|n){}$;\par
\U15.\fi

\M{27}\B\X19:Global states\X${}\mathrel+\E{}$\6
\&{int} \\{natural}${}\K\T{0}{}$;\par
\fi

\N{1}{28}Program entry. A standard Plan9 C program would use these headers.
\Y\B\8\#\&{include} \.{<u.h>}\6
\8\#\&{include} \.{<libc.h>}\6
\8\#\&{include} \.{<ctype.h>}\par
\fi

\M{29}The \PB{\\{main}(\,)} function starts the daemon process and call \PB{%
\\{exits}(\\{nil})}.

\Y\B\X7:Declarations\X\6
\X19:Global states\X\6
\X11:Subroutines\X\7
\1\1\&{void} \\{main}(\&{int} \\{argc}${},\39{}$\&{char} ${}{*}{*}\\{argv})\2%
\2{}$\6
${}\{{}$\1\6
\X3:Variables\X;\6
\.{USED}(\\{argc});\6
\.{USED}(\\{argv});\6
\X2:Setup keyboard\X\6
\&{if} (\\{fork}(\,))\1\5
\\{exits}(\\{nil});\2\6
\X5:Key translation loop\X\6
\4${}\}{}$\2\par
\fi

\N{1}{30}Bugs. The translation could fail if typing is too fast.
\fi

\inx
\fin
\con
